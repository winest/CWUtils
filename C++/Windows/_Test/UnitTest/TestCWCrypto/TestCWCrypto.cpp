// TestCWProcess.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "CWString.h"
#include "CWTime.h"
#include "CWCrypto.h"

#include "_GenerateTmh.h"
#include "TestCWCrypto.tmh"


VOID TestBase64()
{
    wprintf_s( L"\n========== TestBase64() Enter ==========\n" );

    string strOrg = "Just a testing";
    string strBase64Encoded;
    string strBase64Decoded;
    CWUtils::Base64Encode( (CONST UCHAR *)strOrg.c_str() , strOrg.length() , strBase64Encoded , NULL );
    CWUtils::Base64Decode( (CONST UCHAR *)strBase64Encoded.c_str() , strBase64Encoded.length() , strBase64Decoded , NULL );
    wprintf_s( L"%hs => %hs => %hs\n" , strOrg.c_str() , strBase64Encoded.c_str() , strBase64Decoded.c_str() );
    DbgOut( INFO , DBG_TEST , "%hs => %hs => %hs" , strOrg.c_str() , strBase64Encoded.c_str() , strBase64Decoded.c_str() );

    wprintf_s( L"\n========== TestBase64() Leave ==========\n" );
}

VOID TestRc4()
{
    wprintf_s( L"\n========== TestRc4() Enter ==========\n" );
    string strRc4Key = "abcdefg";
    string strOrg = "Just a testing";
    string strRc4Encoded;
    string strRc4Decoded;
    CWUtils::Rc4( (CONST UCHAR *)strOrg.c_str() , strOrg.length() , strRc4Encoded , strRc4Key.c_str() );
    CWUtils::Rc4( (CONST UCHAR *)strRc4Encoded.c_str() , strRc4Encoded.length() , strRc4Decoded , strRc4Key.c_str() );
    //wprintf_s( L"%hs => %hs => %hs\n" , strOrg.c_str() , strRc4Encoded.c_str() , strRc4Decoded.c_str() );
    DbgOut( INFO , DBG_TEST , "%hs => %!HEXDUMP! => %hs" , strOrg.c_str() , _WppHexDump((const UCHAR *)strRc4Encoded.c_str(),strRc4Encoded.length()) , strRc4Decoded.c_str() );
    wprintf_s( L"\n========== TestRc4() Leave ==========\n" );
}

VOID TestRsa()
{
    wprintf_s( L"\n========== TestRsa() Enter ==========\n" );

    wstring wstrErr;
    //Some provider can be found under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\Defaults\Provider
    UCHAR szKey1[] = { 0x06 , 0x02 , 0x00 , 0x00 , 0x00 , 0xA4 , 0x00 , 0x00 ,
                       0x52 , 0x53 , 0x41 , 0x31 , 0x00 , 0x04 , 0x00 , 0x00 ,
                       0x01 , 0x00 , 0x01 , 0x00 , 0x03 , 0x44 , 0x68 , 0x65 , 0x47 , 0xEA , 0x97 , 0x70 , 0x93 , 0x1E , 0x26 , 0x12 ,
                       0x9A , 0xC0 , 0x62 , 0xAF , 0x33 , 0x5D , 0x5C , 0xF9 , 0x47 , 0x68 , 0xBA , 0xCA , 0x92 , 0x71 , 0xD7 , 0x19 , 
                       0xA3 , 0x47 , 0xB9 , 0x2B , 0x1C , 0x15 , 0xD7 , 0xDB , 0x44 , 0x5A , 0x33 , 0x8B , 0x8F , 0xBE , 0x2A , 0x50 ,
                       0x22 , 0x7A , 0x7F , 0x6B , 0x77 , 0x89 , 0xA3 , 0x53 , 0x74 , 0x78 , 0x60 , 0xDB , 0x54 , 0x09 , 0x98 , 0x81 ,
                       0x82 , 0x69 , 0x06 , 0x09 , 0x3B , 0x90 , 0x40 , 0x1E , 0xDD , 0xFE , 0xF9 , 0xA5 , 0x8B , 0x91 , 0xCC , 0x84 ,
                       0x76 , 0x02 , 0x0F , 0x01 , 0xAC , 0x7A , 0xDE , 0xF7 , 0x18 , 0x76 , 0x9E , 0x24 , 0x64 , 0x41 , 0x9A , 0x4B ,
                       0x14 , 0x56 , 0x48 , 0xFB , 0x95 , 0x07 , 0xB1 , 0xEF , 0x00 , 0x86 , 0x26 , 0x51 , 0x96 , 0x4B , 0x18 , 0x39 ,
                       0x32 , 0x17 , 0x9E , 0x51 , 0x7E , 0xB3 , 0xF5 , 0xFF , 0xE1 , 0x09 , 0x5E , 0xE9 , 0x94 , 0x97 , 0x18 , 0x43 ,
                       0x82 , 0xD1 , 0x6F , 0x8C };
    UCHAR szKey2[] = { 0x06 , 0x02 , 0x00 , 0x00 , 0x00 , 0xA4 , 0x00 , 0x00 , 
                       0x52 , 0x53 , 0x41 , 0x31 , 0x00 , 0x04 , 0x00 , 0x00 ,
                       0x01 , 0x00 , 0x01 , 0x00 , 0x03 , 0x44 , 0x68 , 0x65 , 0x47 , 0xEA , 0x97 , 0x70 , 0x93 , 0x1E , 0x26 , 0x12 ,
                       0x9A , 0xC0 , 0x62 , 0xAF , 0x33 , 0x5D , 0x5C , 0xF9 , 0x47 , 0x68 , 0xBA , 0xCA , 0x92 , 0x71 , 0xD7 , 0x19 ,
                       0xA3 , 0x47 , 0xB9 , 0x2B , 0x1C , 0x15 , 0xD7 , 0xDB , 0x44 , 0x5A , 0x33 , 0x8B , 0x8F , 0xBE , 0x2A , 0x50 ,
                       0x22 , 0x7A , 0x7F , 0x6B , 0x77 , 0x89 , 0xA3 , 0x53 , 0x74 , 0x78 , 0x60 , 0xDB , 0x54 , 0x09 , 0x98 , 0x81 ,
                       0x82 , 0x69 , 0x06 , 0x09 , 0x3B , 0x90 , 0x40 , 0x1E , 0xDD , 0xFE , 0xF9 , 0xA5 , 0x8B , 0x91 , 0xCC , 0x84 ,
                       0x76 , 0x02 , 0x0F , 0x01 , 0xAC , 0x7A , 0xDE , 0xF7 , 0x18 , 0x76 , 0x9E , 0x24 , 0x64 , 0x41 , 0x9A , 0x4B ,
                       0x14 , 0x56 , 0x48 , 0xFB , 0x95 , 0x07 , 0xB1 , 0xEF , 0x00 , 0x86 , 0x26 , 0x51 , 0x96 , 0x4B , 0x18 , 0x39 ,
                       0x32 , 0x17 , 0x9E , 0x51 , 0x7E , 0xB3 , 0xF5 , 0xFF , 0xE1 , 0x09 , 0x5E , 0xE9 , 0x94 , 0x97 , 0x18 , 0x43 ,
                       0x82 , 0xD1 , 0x6F , 0x8C };

    CWUtils::CRsa rsa;
    if ( FALSE == rsa.ImportAndUseKey( szKey1 , sizeof(szKey1) , L"MyContainer" , MS_ENHANCED_PROV_W ) )
    {
        CWUtils::GetLastErrorStringW( wstrErr );
        wprintf_s( L"ImportAndUseKey() failed. GetLastError()=0x%08X (%ws)\n" , GetLastError() , wstrErr.c_str() );
    }

    UCHAR szData[2048/8] = { 'a' , 'b' , 'c' };
    DWORD dwDataLen = 3;
    if ( FALSE == rsa.Encrypt( szData , sizeof(szData) , &dwDataLen ) )
    {
        CWUtils::GetLastErrorStringW( wstrErr );
        wprintf_s( L"Encrypt() failed. GetLastError()=0x%08X (%ws)\n" , GetLastError() , wstrErr.c_str() );
    }

    DbgOut( INFO , DBG_TEST , "szData=%!HEXDUMP!" , _WppHexDump(szData,dwDataLen) );
    rsa.CloseKey();

    wprintf_s( L"\n========== TestRsa() Leave ==========\n" );
}


INT wmain( INT aArgc , WCHAR * aArgv[] )
{
    WPP_INIT_TRACING( L"TestCWCrypto" );
    DbgOut( INFO , DBG_TEST , "Enter" );

    for ( int i = 0 ; i < aArgc ; i++ )
    {
        wprintf_s( L"aArgv[%d]=%ws\n" , i , aArgv[i] );
    }
    wprintf_s( L"Start\n" );

    CWUtils::CStopWatch stopWatch;
    stopWatch.Start();

    do 
    {
        TestBase64();
        TestRc4();
        //TestRsa();
    } while ( 0 );

    stopWatch.Stop();
    wprintf_s( L"%I64u micro-sec\n" , stopWatch.GetIntervalInMicro() );
    wprintf_s( L"End of the program\n" );
    DbgOut( INFO , DBG_TEST , "Leave" );
    WPP_CLEANUP();
    system( "pause" );
    return 0;
}

